<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GCP Professional Cloud Architect Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* --- New Light Theme --- */

        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Light Slate Background */
            background-image: radial-gradient(at 27% 37%, hsla(215, 98%, 61%, 0.15) 0px, transparent 50%), 
                              radial-gradient(at 97% 21%, hsla(145, 98%, 61%, 0.15) 0px, transparent 50%),
                              radial-gradient(at 52% 99%, hsla(355, 98%, 61%, 0.15) 0px, transparent 50%),
                              radial-gradient(at 10% 29%, hsla(256, 96%, 61%, 0.15) 0px, transparent 50%),
                              radial-gradient(at 97% 96%, hsla(38, 60%, 62%, 0.15) 0px, transparent 50%),
                              radial-gradient(at 33% 50%, hsla(222, 67%, 73%, 0.15) 0px, transparent 50%),
                              radial-gradient(at 79% 53%, hsla(343, 68%, 79%, 0.15) 0px, transparent 50%);
            background-size: 400% 400%;
            animation: gradient-animation 15s ease infinite;
            color: #1e293b; /* Dark Slate Text */
            display: flex;
            flex-direction: column;
        }

        /* --- Light Card Style --- */
        .card {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
        }

        /* --- Header --- */
        #main-header h1 {
            color: #0f172a; /* Darker Slate for Heading */
        }
        #main-header p {
            color: #475569; /* Medium Slate for Subheading */
        }

        /* --- Light Quiz Option Styles --- */
        .quiz-option {
            transition: all 0.25s ease-in-out;
            cursor: pointer;
            border: 2px solid #e2e8f0; /* Light Gray Border */
            background-color: #ffffff;
        }
        .quiz-option:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: #3b82f6; /* Blue-500 */
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.15);
        }
        .quiz-option.selected {
            background-color: #eff6ff; /* Blue-50 */
            border-color: #2563eb; /* Blue-600 */
        }
        .quiz-option.correct {
            background-color: rgba(34, 197, 94, 0.1);
            border-color: #16a34a; /* Green-600 */
        }
        .quiz-option.incorrect {
            background-color: rgba(239, 68, 68, 0.1);
            border-color: #ef4444; /* Red-500 */
        }
        .status-icon {
            width: 24px;
            height: 24px;
        }

        /* --- Feedback Card --- */
        .feedback-card {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out, margin 0.5s ease-in-out, opacity 0.5s ease-in-out;
            opacity: 0;
        }
        .feedback-card.show {
            max-height: 800px;
            padding-top: 1.5rem;
            padding-bottom: 1.5rem;
            margin-top: 1.5rem;
            opacity: 1;
        }

        /* --- State for Answered Questions --- */
        .answered .quiz-option:not(.selected):not(.correct) {
            cursor: not-allowed;
            opacity: 0.6;
            filter: grayscale(50%);
        }
        .answered .quiz-option:hover {
            transform: none;
            box-shadow: none;
        }

        /* --- Light Button Styles --- */
        .btn {
            transition: all 0.2s ease-in-out;
            border-radius: 0.5rem;
            font-weight: 600;
            border: 1px solid transparent;
        }
        .btn:hover {
            transform: translateY(-2px) scale(1.02);
        }
        .btn:active {
            transform: translateY(-1px) scale(1.0);
        }
        .btn-primary {
            background-image: linear-gradient(to right, #3b82f6, #6366f1); /* Blue to Indigo */
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.2);
        }
        .btn-primary:hover {
             filter: brightness(1.1);
             box-shadow: 0 0 25px rgba(59, 130, 246, 0.4);
        }
        .btn-secondary {
            background-color: #e5e7eb; /* Gray-200 */
            color: #374151; /* Gray-700 */
            border-color: #d1d5db; /* Gray-300 */
        }
        .btn-secondary:hover {
            background-color: #d1d5db; /* Gray-300 */
            border-color: #9ca3af; /* Gray-400 */
        }

        /* --- Light Progress Bar --- */
        #progress-container {
            width: 100%;
            background-color: #e5e7eb; /* Gray-200 */
            border-radius: 9999px;
            height: 12px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        #progress-bar {
            background-image: linear-gradient(to right, #3b82f6, #8b5cf6);
            height: 100%;
            border-radius: 9999px;
            transition: width 0.4s ease-in-out;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.4);
        }
        
        /* --- Light Results & Review --- */
        #score-circle {
            background: conic-gradient(from 180deg at 50% 50%, #f3f4f6 0%, #ffffff 100%);
            border-color: #e5e7eb;
        }
        #score-text {
            color: #1d4ed8; /* Blue-700 */
        }
        .review-answer-correct {
            color: #15803d; /* Green-700 */
            font-weight: 600;
        }
        .review-answer-incorrect {
            color: #b91c1c; /* Red-700 */
            font-weight: 600;
        }
        
        /* --- Scrolling Fixes --- */
        #review-content {
            max-height: 65vh; 
            overflow-y: auto;
            padding-right: 1rem; 
        }

        .feedback-explanations {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        /* Custom scrollbar for webkit browsers */
        #review-content::-webkit-scrollbar, .feedback-explanations::-webkit-scrollbar {
            width: 8px;
        }

        #review-content::-webkit-scrollbar-track, .feedback-explanations::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 10px;
        }

        #review-content::-webkit-scrollbar-thumb, .feedback-explanations::-webkit-scrollbar-thumb {
            background-color: #94a3b8;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
        }

        #review-content::-webkit-scrollbar-thumb:hover, .feedback-explanations::-webkit-scrollbar-thumb:hover {
            background-color: #64748b;
        }
    </style>
</head>
<body class="text-slate-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-6xl flex flex-col flex-grow">
        <header id="main-header" class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-extrabold flex items-center justify-center">
                <span class="inline-block align-middle w-10 h-10 mr-3">
                    <svg viewBox="0 0 108 72" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M85.333 29.333c-2.07-12.2-12.72-21.333-25.333-21.333-8.107 0-15.307 3.84-19.893 9.76C37.333 17.013 33.813 16 30 16c-8.827 0-16 7.173-16 16 0 .613.053.933.16.1.213-3.947 3.52-7.1 7.547-7.1h1.76c.693 0 1.333.32 1.76.853.48-5.387 5.12-9.547 10.773-9.547 6.187 0 11.2 4.907 11.307 11.093.053.853.747 1.547 1.6 1.547h.427c5.44 0 9.866 4.427 9.866 9.867 0 5.173-4.053 9.493-9.28 9.813H37.333c-6.627 0-12 5.373-12 12s5.373 12 12 12h48c9.707 0 17.333-7.947 17.333-17.333 0-9.28-7.253-16.853-16.333-17.333z" fill="#4285F4"/>
                        <path d="M37.333 53.333c-2.293 0-4.373-1.013-5.813-2.613-1.494-1.6-2.454-3.84-2.454-6.054 0-4.906 3.947-8.853 8.854-8.853h48c4.906 0 8.853 3.947 8.853 8.853 0 4.907-3.947 8.854-8.853 8.854H37.333z" fill="#1A73E8"/>
                        <path d="M30 23c-4.97 0-9 4.03-9 9s4.03 9 9 9h6.667c.107-1.386.427-2.72.96-4-1.813-.64-3.093-2.4-3.093-4.453 0-2.614 2.133-4.747 4.747-4.747h1.066c.214-3.84 3.467-6.8 7.334-6.8 3.413 0 6.346 2.347 7.146 5.493C55.467 25.12 56.693 24 58 24c3.307 0 6 2.693 6 6 0 .693-.107 1.333-.32 1.973.853.213 1.6.64 2.24 1.173-1.493-4.48-5.653-7.813-10.587-7.813-4.213 0-7.946 2.56-9.653 6.24C44.427 26.133 40.853 23 36.667 23H30z" fill="#E8F0FE"/>
                    </svg>
                </span>
                GCP Architect Quiz üß†
            </h1>
            <p class="mt-2 text-lg">Test your knowledge and prepare for certification!</p>
        </header>

        <main class="flex-grow">
            <!-- The quiz content will be dynamically inserted here by script.js -->
            <div id="quiz-container" class="card p-6 sm:p-8 rounded-2xl">
            </div>

            <!-- Navigation controls for the quiz -->
            <div id="navigation-container" class="mt-8 flex items-center justify-between gap-4">
                <button id="prev-btn" class="btn btn-secondary py-2 px-4 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">Previous</button>
                
                <div class="flex-grow text-center">
                    <div id="progress-container">
                        <div id="progress-bar" style="width: 0%;"></div>
                    </div>
                    <div id="progress-indicator" class="text-sm font-medium text-slate-500 mt-2">
                        Question <span id="current-q-span">1</span> of <span id="total-q-span">60</span>
                    </div>
                </div>
                
                <button id="next-btn" class="btn btn-primary py-2 px-4">Next</button>
            </div>

            <!-- Results screen, hidden by default -->
            <div id="results-container" class="hidden text-center card p-8 rounded-2xl">
                <h2 class="text-3xl font-bold mb-4">üèÜ Quiz Complete! üèÜ</h2>
                <p class="text-lg text-slate-700 mb-2">Your Final Score:</p>
                <div id="score-circle" class="relative w-40 h-40 mx-auto flex items-center justify-center rounded-full mb-6 border-4">
                    <span id="score-text" class="text-5xl font-extrabold"></span>
                </div>
                <p id="score-summary" class="text-slate-600 text-lg mb-8"></p>
                <div class="flex flex-col sm:flex-row justify-center gap-4">
                     <button id="review-btn" class="btn btn-secondary py-3 px-6">Review Answers</button>
                     <button id="restart-btn" class="btn btn-primary py-3 px-6">Restart Quiz</button>
                </div>
            </div>
            
            <!-- Review screen, hidden by default -->
            <div id="review-container" class="hidden card p-6 sm:p-8 rounded-2xl">
                 <h2 class="text-3xl font-bold mb-6 text-center">üìã Answer Review</h2>
                 <div id="review-content" class="space-y-6">
                     <!-- Review content will be dynamically inserted here -->
                 </div>
                 <div class="text-center mt-8">
                     <button id="back-to-score-btn" class="btn btn-primary py-2 px-4">Back to Score</button>
                 </div>
            </div>
        </main>
    </div>
    
    <footer class="text-center p-4 mt-4">
        <p class="text-sm text-slate-500">Made with ‚ù§Ô∏è by Arjun</p>
    </footer>

    <script>
        // --- DATA ---
        const quizData = [
            {
                title: "Q1: API Versioning (Same DNS/SSL)",
                description: "Your company has decided to make a major revision of their API in order to create better experiences for their developers. They need to keep the old version of the API available and deployable, while allowing new customers and testers to try out the new API. They want to keep the same SSL and DNS records in place to serve both APIs. What should they do?",
                options: [
                    "Configure a new load balancer",
                    "Reconfigure old clients",
                    "Have the old API forward traffic to the new API based on the path",
                    "Use separate backend pools for each API path behind the load balancer"
                ],
                correctAnswer: "Use separate backend pools for each API path behind the load balancer",
                feedback: {
                    "Configure a new load balancer": "Incorrect. This would likely require new DNS/SSL records.",
                    "Reconfigure old clients": "Incorrect. This would disrupt existing clients and is not a good practice for API versioning.",
                    "Have the old API forward traffic to the new API based on the path": "Incorrect. This approach is risky and tightly couples the two API versions.",
                    "Use separate backend pools for each API path behind the load balancer": "Correct! An HTTP(S) Load Balancer can use path-based routing (e.g., /v1/*, /v2/*) to direct traffic to different backends. This is the standard way to manage API versions under a single domain."
                }
            },
            {
                title: "Q2: Data Storage for Scalable SQL Analysis",
                description: "Your company plans to migrate a multi-petabyte data set to the cloud. The data set must be available 24 hours a day. Your business analysts have experience only with using a SQL interface. How should you store the data to optimize it for ease of analysis?",
                options: [
                    "Load data into Google BigQuery",
                    "Insert data into Google Cloud SQL",
                    "Put flat files into Google Cloud Storage",
                    "Stream into Google Cloud Datastore"
                ],
                correctAnswer: "Load data into Google BigQuery",
                feedback: {
                    "Load data into Google BigQuery": "Correct! BigQuery is a serverless, highly scalable data warehouse designed for running SQL queries on massive (petabyte-scale) datasets.",
                    "Insert data into Google Cloud SQL": "Incorrect. Cloud SQL is a relational database service (OLTP) and is not designed for petabyte-scale analytics.",
                    "Put flat files into Google Cloud Storage": "Incorrect. While Cloud Storage is a good place to store the files, it does not offer a direct SQL interface for analysis.",
                    "Stream into Google Cloud Datastore": "Incorrect. Datastore is a NoSQL database and does not use a SQL interface."
                }
            },
            {
                title: "Q3: Migrating a J2EE Application - Recommended Practices",
                description: "The operations manager asks you for a list of recommended practices that she should consider when migrating a J2EE application to the cloud. Which three practices should you recommend? (Choose three.)",
                type: "CHECKBOX",
                options: [
                    "Port the application code to run on Google App Engine",
                    "Integrate Cloud Dataflow into the application to capture real-time metrics",
                    "Instrument the application with a monitoring tool like Stackdriver Debugger",
                    "Select an automation framework to reliably provision the cloud infrastructure",
                    "Deploy a continuous integration tool with automated testing in a staging environment",
                    "Migrate from MySQL to a managed NoSQL database like Google Cloud Datastore or Bigtable"
                ],
                correctAnswers: [
                    "Instrument the application with a monitoring tool like Stackdriver Debugger",
                    "Select an automation framework to reliably provision the cloud infrastructure",
                    "Deploy a continuous integration tool with automated testing in a staging environment"
                ],
                feedback: {
                    "Port the application code to run on Google App Engine": "Incorrect. This is a specific re-platforming strategy, not a universal best practice for all initial migrations.",
                    "Integrate Cloud Dataflow into the application to capture real-time metrics": "Incorrect. Dataflow is for large-scale data processing, not application metrics. Cloud Monitoring is the appropriate tool.",
                    "Instrument the application with a monitoring tool like Stackdriver Debugger": "Correct! Gaining operational visibility through monitoring and debugging is a fundamental practice for any cloud application.",
                    "Select an automation framework to reliably provision the cloud infrastructure": "Correct! Using Infrastructure as Code (IaC) ensures consistent, repeatable, and automated provisioning of environments.",
                    "Deploy a continuous integration tool with automated testing in a staging environment": "Correct! Implementing CI/CD is essential for improving release velocity, quality, and reliability.",
                    "Migrate from MySQL to a managed NoSQL database like Google Cloud Datastore or Bigtable": "Incorrect. This represents a major database re-architecture and is not a typical initial practice for migration."
                }
            },
            {
                title: "Q4: App Engine Session State Issue",
                description: "Your news feed web service has the following code running on Google App Engine. During peak load, users report that they can see news articles they already viewed. (Code shows sessions = {} global variable). What is the most likely cause of this problem?",
                options: [
                    "The session variable is local to just a single instance",
                    "The session variable is being overwritten in Cloud Datastore",
                    "The URL of the API needs to be modified to prevent caching",
                    "The HTTP Expires header needs to be set to -1 stop caching"
                ],
                correctAnswer: "The session variable is local to just a single instance",
                feedback: {
                    "The session variable is local to just a single instance": "Correct! In a scaled environment like App Engine, each request from a user can be served by a different instance. Storing session state in instance memory means it is not shared, leading to inconsistent user experiences.",
                    "The session variable is being overwritten in Cloud Datastore": "Incorrect. The problem description implies the session state is in a global variable, not stored in Datastore.",
                    "The URL of the API needs to be modified to prevent caching": "Incorrect. This is an issue with server-side state management, not client-side caching.",
                    "The HTTP Expires header needs to be set to -1 stop caching": "Incorrect. This is related to client-side caching, not server-side session state inconsistency."
                }
            },
            {
                title: "Q5: Logging Tool Assessment",
                description: "An application development team believes their current logging tool will not meet their needs for their new cloud-based product. They want a better tool to capture errors and help them analyze their historical log data. You want to help them find a solution that meets their needs. What should you do?",
                options: [
                    "Direct them to download and install the Google StackDriver logging agent",
                    "Send them a list of online resources about logging best practices",
                    "Help them define their requirements and assess viable logging tools",
                    "Help them upgrade their current tool to take advantage of any new features"
                ],
                correctAnswer: "Help them define their requirements and assess viable logging tools",
                feedback: {
                    "Direct them to download and install the Google StackDriver logging agent": "Incorrect. Recommending a specific tool without first understanding the requirements is a premature solution.",
                    "Send them a list of online resources about logging best practices": "Incorrect. While helpful, this is passive and does not directly address their need to find a solution.",
                    "Help them define their requirements and assess viable logging tools": "Correct! The essential first step in any solution design is to understand the requirements, constraints, and goals. This allows for a proper assessment of all viable options.",
                    "Help them upgrade their current tool to take advantage of any new features": "Incorrect. This assumes their current tool is sufficient, which the team already believes is not the case."
                }
            },
            {
                title: "Q6: Compute Engine Instance Migration",
                description: "Your company wants to move a development application from an on-premises server to Google Cloud. The application is a three-tier web application, with the web server, application server, and database server each running on a separate virtual machine. The application will be used by 10 developers. You need to migrate the virtual machines (VMs) and establish connectivity between them. What should you do?",
                options: [
                    "Use Compute Engine for each server, and deploy a global load balancer.",
                    "Use Compute Engine for each server, and deploy a Cloud VPN.",
                    "Use Compute Engine for each server, and create a firewall rule to allow traffic between VMs.",
                    "Use Compute Engine for each server, and set up a VPC Network and Firewall rules."
                ],
                correctAnswer: "Use Compute Engine for each server, and set up a VPC Network and Firewall rules.",
                feedback: {
                    "Use Compute Engine for each server, and deploy a global load balancer.": "Incorrect. A global load balancer is for distributing external traffic, not for establishing basic internal connectivity between VMs.",
                    "Use Compute Engine for each server, and deploy a Cloud VPN.": "Incorrect. A Cloud VPN is used to connect an on-premises network to a GCP VPC, not for connecting VMs within the same VPC.",
                    "Use Compute Engine for each server, and create a firewall rule to allow traffic between VMs.": "Incorrect. While a firewall rule is needed, it must be created within a VPC Network. The VPC is the foundational networking component.",
                    "Use Compute Engine for each server, and set up a VPC Network and Firewall rules.": "Correct! VMs need to reside in a VPC to communicate. Firewall rules within that VPC are then used to control the specific traffic allowed between them."
                }
            },
            {
                title: "Q7: Choosing a Database for Financial Transactions",
                description: "Your company is developing an application that stores highly sensitive financial transactions. These transactions need to be stored in a database that offers strong ACID compliance. You need to select a database to meet this requirement. Which database should you use?",
                options: [
                    "Google Cloud Datastore",
                    "Google Cloud Bigtable",
                    "Google Cloud Spanner",
                    "Google Cloud Firestore in Native Mode"
                ],
                correctAnswer: "Google Cloud Spanner",
                feedback: {
                    "Google Cloud Datastore": "Incorrect. Datastore is a NoSQL database and does not offer the strong, global ACID compliance required for financial transactions.",
                    "Google Cloud Bigtable": "Incorrect. Bigtable is a NoSQL wide-column store designed for high-throughput analytical and operational workloads, not for ACID transactions.",
                    "Google Cloud Spanner": "Correct! Cloud Spanner is a globally distributed, relational database that provides strong ACID compliance, making it ideal for financial applications.",
                    "Google Cloud Firestore in Native Mode": "Incorrect. Firestore is a NoSQL document database and does not provide the strong consistency guarantees of Spanner."
                }
            },
            {
                title: "Q8: Automating VM Configuration After Deployment",
                description: "Your company needs to deploy a large number of virtual machines (VMs) to Google Cloud. These VMs must run a specific set of configurations and software after they are deployed. You need to manage the configuration consistently and efficiently. What should you do?",
                options: [
                    "Write a custom deployment script and run it manually on each VM.",
                    "Use a startup script on each VM to configure it after deployment.",
                    "Create a custom VM image that includes all required configurations and software.",
                    "Develop a Kubernetes Deployment to manage the VM configuration."
                ],
                correctAnswer: "Create a custom VM image that includes all required configurations and software.",
                feedback: {
                    "Write a custom deployment script and run it manually on each VM.": "Incorrect. This is manual, error-prone, and not efficient for a large number of VMs.",
                    "Use a startup script on each VM to configure it after deployment.": "Incorrect. While startup scripts can work, they add to the boot time of each VM. A custom image is more efficient as the software is pre-installed.",
                    "Create a custom VM image that includes all required configurations and software.": "Correct! Creating a 'golden image' ensures that every VM is deployed with the exact same configuration and software, leading to consistency and faster startup times.",
                    "Develop a Kubernetes Deployment to manage the VM configuration.": "Incorrect. Kubernetes is used for orchestrating containers, not for managing the configuration of individual VMs."
                }
            },
            {
                title: "Q9: High Availability for Web Application Backend",
                description: "Your company has a multi-tier web application running on Compute Engine. The backend application servers are deployed across multiple zones in a region using managed instance groups. You need to ensure the application remains highly available even if an entire zone becomes unavailable. What should you do?",
                options: [
                    "Configure a regional managed instance group with autoscaling.",
                    "Configure an HTTP(S) Load Balancer in front of the managed instance groups.",
                    "Configure a health check on the managed instance groups and a Load Balancer.",
                    "Configure the application with an internal load balancer across multiple zones."
                ],
                correctAnswer: "Configure an HTTP(S) Load Balancer in front of the managed instance groups.",
                feedback: {
                    "Configure a regional managed instance group with autoscaling.": "Incorrect. A regional MIG is a key component, but it doesn't handle distributing traffic from external users.",
                    "Configure an HTTP(S) Load Balancer in front of the managed instance groups.": "Correct! The load balancer provides a single entry point for traffic and will automatically distribute it to healthy instances in the available zones, bypassing any unavailable zone.",
                    "Configure a health check on the managed instance groups and a Load Balancer.": "Incorrect. Health checks are a necessary part of the solution, but they are a feature of the load balancer and MIG, not the entire solution itself.",
                    "Configure the application with an internal load balancer across multiple zones.": "Incorrect. An internal load balancer is for traffic within your VPC, not for external traffic to a web application."
                }
            },
            {
                title: "Q10: Database for Financial Transactions with Auditing",
                description: "Your company stores highly sensitive financial transactions. These transactions need to be stored in a database that offers strong ACID compliance. Additionally, the database must support auditing to track changes to the data. Which database should you use?",
                options: [
                    "Google Cloud Datastore",
                    "Google Cloud Bigtable",
                    "Google Cloud Spanner",
                    "Google Cloud Firestore in Native Mode"
                ],
                correctAnswer: "Google Cloud Spanner",
                feedback: {
                    "Google Cloud Datastore": "Incorrect. Lacks strong ACID compliance.",
                    "Google Cloud Bigtable": "Incorrect. NoSQL database not designed for ACID transactions.",
                    "Google Cloud Spanner": "Correct! Spanner provides strong, global ACID compliance, which is essential for financial transactions. Auditing can be implemented using features like audit logs or change streams.",
                    "Google Cloud Firestore in Native Mode": "Incorrect. Lacks the strict consistency guarantees of Spanner."
                }
            },
            {
                title: "Q11: Selecting a Storage for Analytics Workload",
                description: "Your company has a large collection of unstructured data (images, videos, documents). They want to store this data in Google Cloud and make it available for future analysis by data scientists. The data volume is expected to grow significantly. Which storage solution should you choose?",
                options: [
                    "Google Cloud Storage (Standard storage class)",
                    "Google Cloud Storage (Nearline storage class)",
                    "Google Cloud Filestore",
                    "Google Cloud SQL"
                ],
                correctAnswer: "Google Cloud Storage (Standard storage class)",
                feedback: {
                    "Google Cloud Storage (Standard storage class)": "Correct! Cloud Storage is a scalable object store perfect for unstructured data. The Standard class is suitable for data that may be frequently accessed for analysis.",
                    "Google Cloud Storage (Nearline storage class)": "Incorrect. Nearline is for data accessed less than once a month, which might be too slow or costly for active analysis.",
                    "Google Cloud Filestore": "Incorrect. Filestore provides a managed file system (NFS), which is not as scalable or cost-effective for large-scale object storage as Cloud Storage.",
                    "Google Cloud SQL": "Incorrect. Cloud SQL is a relational database and is not suitable for storing large, unstructured files."
                }
            },
            {
                title: "Q12: Network Design for On-Prem to Cloud Migration (VPC)",
                description: "Your company plans to migrate its on-premises data center to Google Cloud. They want to ensure seamless network connectivity between their existing on-premises network and their new Google Cloud resources. They need a logically isolated, high-performance network in the cloud. Which network construct should you set up in Google Cloud?",
                options: [
                    "Shared VPC",
                    "VPC Network",
                    "Firewall Rules",
                    "VPN Gateway"
                ],
                correctAnswer: "VPC Network",
                feedback: {
                    "Shared VPC": "Incorrect. Shared VPC is a way to use a VPC across multiple projects, but the fundamental construct is the VPC Network itself.",
                    "VPC Network": "Correct! A Virtual Private Cloud (VPC) Network is the foundational, logically isolated private network within GCP where you place your resources.",
                    "Firewall Rules": "Incorrect. Firewall rules control traffic within a VPC; they do not create the network.",
                    "VPN Gateway": "Incorrect. A VPN Gateway is a component used to connect an on-premises network to a VPC, but it is not the network itself."
                }
            },
            {
                title: "Q13: Cloud Cost Optimization for Compute Engine",
                description: "Your company is running several non-critical Compute Engine instances that process batch jobs. These jobs can tolerate some interruptions and have flexible start/stop times. You want to optimize costs for these instances. What type of Compute Engine instance should you recommend?",
                options: [
                    "Standard instances",
                    "Preemptible instances",
                    "Custom machine types",
                    "Sole-tenant nodes"
                ],
                correctAnswer: "Preemptible instances",
                feedback: {
                    "Standard instances": "Incorrect. These are the default and do not offer specific cost savings for interruptible workloads.",
                    "Preemptible instances": "Correct! Preemptible VMs (PVMs) offer massive discounts (up to 80%) in exchange for the possibility of being shut down (preempted) by Google. They are perfect for fault-tolerant, non-critical batch jobs.",
                    "Custom machine types": "Incorrect. While custom machine types can save money by right-sizing VMs, they don't offer the deep discounts of preemptible instances for this use case.",
                    "Sole-tenant nodes": "Incorrect. These are more expensive and are used for compliance or licensing requirements that need dedicated hardware."
                }
            },
            {
                title: "Q14: Securing Access to Cloud Storage (Specific Users)",
                description: "Your company wants to grant specific individuals in their data science team read-only access to a Google Cloud Storage bucket containing sensitive research data. You need to ensure access is tightly controlled and follows the principle of least privilege. What is the most secure way to grant this access?",
                options: [
                    "Make the bucket publicly readable",
                    "Grant the roles/storage.objectViewer role to individual users",
                    "Grant the roles/storage.admin role to the data science team's service account",
                    "Set up signed URLs for each object they need to access"
                ],
                correctAnswer: "Grant the roles/storage.objectViewer role to individual users",
                feedback: {
                    "Make the bucket publicly readable": "Incorrect. This is highly insecure and exposes the sensitive data to everyone on the internet.",
                    "Grant the roles/storage.objectViewer role to individual users": "Correct! This follows the principle of least privilege by granting only the necessary read-only permission (objectViewer) directly to the specific users who need it.",
                    "Grant the roles/storage.admin role to the data science team's service account": "Incorrect. This grants full administrative control, which violates the principle of least privilege.",
                    "Set up signed URLs for each object they need to access": "Incorrect. While signed URLs are secure, they are impractical for granting ongoing access to a whole bucket for a team. They are better for temporary, programmatic access to specific objects."
                }
            },
            {
                title: "Q15: Choosing a Database for High-Throughput IoT Data",
                description: "Your company is developing an IoT application that collects sensor data from millions of devices. This data needs to be ingested at extremely high throughput and made available for near real-time analytics. The data is mostly time-series based. Which database should you use?",
                options: [
                    "Google Cloud SQL",
                    "Google Cloud Spanner",
                    "Google Cloud Bigtable",
                    "Google Cloud Datastore"
                ],
                correctAnswer: "Google Cloud Bigtable",
                feedback: {
                    "Google Cloud SQL": "Incorrect. A relational database like Cloud SQL is not designed to handle the massive write throughput of millions of IoT devices.",
                    "Google Cloud Spanner": "Incorrect. Spanner is for transactional consistency (ACID), not for the raw, high-throughput ingestion of time-series data.",
                    "Google Cloud Bigtable": "Correct! Bigtable is a NoSQL wide-column store specifically designed for large-scale, low-latency workloads, making it perfect for ingesting and analyzing high-throughput time-series and IoT data.",
                    "Google Cloud Datastore": "Incorrect. Datastore is a document database for application data and does not scale to the level required for millions of IoT devices."
                }
            },
            {
                title: "Q16: Data Transfer for Large On-Premises Dataset to GCP",
                description: "Your company needs to migrate a large on-premises dataset (several petabytes) to Google Cloud Storage. The internet connection at the data center is slow and unreliable. You need a reliable and fast method for this initial bulk data transfer. What should you do?",
                options: [
                    "Use gsutil rsync to synchronize data to Cloud Storage.",
                    "Use Transfer Appliance to transfer the data.",
                    "Use Storage Transfer Service to transfer the data.",
                    "Use a Direct Peering connection to transfer the data."
                ],
                correctAnswer: "Use Transfer Appliance to transfer the data.",
                feedback: {
                    "Use gsutil rsync to synchronize data to Cloud Storage.": "Incorrect. This relies on the slow and unreliable internet connection and would take an extremely long time.",
                    "Use Transfer Appliance to transfer the data.": "Correct! For petabyte-scale transfers with poor network connectivity, the physical Transfer Appliance allows you to ship the data directly to Google for ingestion, bypassing the network.",
                    "Use Storage Transfer Service to transfer the data.": "Incorrect. This service is for transferring data from other cloud providers or online sources and still relies on network connectivity.",
                    "Use a Direct Peering connection to transfer the data.": "Incorrect. Peering is for network traffic exchange, not a solution for a one-time bulk data transfer with an unreliable link."
                }
            },
            {
                title: "Q17: Managing Configuration for Multiple Applications on GKE",
                description: "Your company is running multiple containerized applications on Google Kubernetes Engine (GKE). Each application has its own set of configurations (e.g., API keys, database connection strings, environment variables) that need to be managed securely and updated easily without redeploying the applications. What should you use to manage these configurations?",
                options: [
                    "Kubernetes Secrets for sensitive data, and ConfigMaps for non-sensitive data.",
                    "Store all configurations as environment variables directly in the Deployment manifest.",
                    "Store all configurations in a Cloud Storage bucket and retrieve them at runtime.",
                    "Use a custom solution to store and inject configurations into pods."
                ],
                correctAnswer: "Kubernetes Secrets for sensitive data, and ConfigMaps for non-sensitive data.",
                feedback: {
                    "Kubernetes Secrets for sensitive data, and ConfigMaps for non-sensitive data.": "Correct! This is the standard, native Kubernetes way to manage configuration. Secrets are for sensitive data, and ConfigMaps are for non-sensitive configuration, both of which can be updated independently of the application pods.",
                    "Store all configurations as environment variables directly in the Deployment manifest.": "Incorrect. This is insecure for sensitive data and inflexible, as it requires a redeployment to change any configuration.",
                    "Store all configurations in a Cloud Storage bucket and retrieve them at runtime.": "Incorrect. This requires custom logic within the application and is less integrated than using native Kubernetes objects.",
                    "Use a custom solution to store and inject configurations into pods.": "Incorrect. It's almost always better to use the standard, built-in solution rather than creating a custom one."
                }
            },
            {
                title: "Q18: Deploying a Scalable Microservices Architecture",
                description: "Your company wants to develop a new application using a microservices architecture. They need a platform that can automatically scale individual microservices, handle service discovery, and provide load balancing between them. Which Google Cloud service should you choose?",
                options: [
                    "Google Compute Engine",
                    "Google Kubernetes Engine (GKE)",
                    "Google App Engine Standard",
                    "Google Cloud Functions"
                ],
                correctAnswer: "Google Kubernetes Engine (GKE)",
                feedback: {
                    "Google Compute Engine": "Incorrect. This provides raw VMs and requires you to manually set up and manage all the orchestration for microservices.",
                    "Google Kubernetes Engine (GKE)": "Correct! GKE is the industry-standard container orchestration platform, designed specifically to run, manage, and scale microservices with built-in features for service discovery, load balancing, and autoscaling.",
                    "Google App Engine Standard": "Incorrect. While App Engine supports services, it is more opinionated and offers less flexibility for complex microservices architectures compared to GKE.",
                    "Google Cloud Functions": "Incorrect. This is for serverless functions (FaaS), not for orchestrating a complex system of long-running microservices."
                }
            },
            {
                title: "Q19: Disaster Recovery for Cloud SQL (RPO/RTO)",
                description: "Your company is running a critical application using Google Cloud SQL for MySQL. They need a disaster recovery strategy that ensures a Recovery Point Objective (RPO) of near zero and a Recovery Time Objective (RTO) in minutes. What should you do?",
                options: [
                    "Enable automated daily backups.",
                    "Configure Point-in-Time Recovery.",
                    "Set up a read replica in a different region.",
                    "Configure High Availability (HA) with cross-region replication."
                ],
                correctAnswer: "Configure High Availability (HA) with cross-region replication.",
                feedback: {
                    "Enable automated daily backups.": "Incorrect. This results in a high RPO (up to 24 hours of data loss) and a high RTO (time to restore the backup).",
                    "Configure Point-in-Time Recovery.": "Incorrect. This helps reduce RPO but still involves a manual restoration process, leading to a higher RTO.",
                    "Set up a read replica in a different region.": "Incorrect. A standard read replica has asynchronous replication, which means there can be some data loss (non-zero RPO). Failover is also typically a manual process.",
                    "Configure High Availability (HA) with cross-region replication.": "Correct! Cloud SQL's HA configuration with cross-region replication provides a synchronous standby instance in another region, enabling automatic failover with near-zero RPO and an RTO of minutes."
                }
            },
            {
                title: "Q20: Firewall Rule for Specific IP Address Range",
                description: "You need to create a firewall rule in your GCP VPC network that allows incoming HTTP traffic from 192.168.1.0/24. Which configuration should you use for the firewall rule?",
                options: [
                    "Direction: Egress, Source IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80",
                    "Direction: Ingress, Source IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80",
                    "Direction: Egress, Destination IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80",
                    "Direction: Ingress, Destination IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80"
                ],
                correctAnswer: "Direction: Ingress, Source IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80",
                feedback: {
                    "Direction: Egress, Source IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80": "Incorrect. Egress means outgoing traffic.",
                    "Direction: Ingress, Source IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80": "Correct! Ingress means incoming traffic, and 'Source IP ranges' specifies where the traffic is allowed to originate from.",
                    "Direction: Egress, Destination IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80": "Incorrect. Egress means outgoing traffic.",
                    "Direction: Ingress, Destination IP ranges: 192.168.1.0/24, Protocols and ports: tcp:80": "Incorrect. 'Destination IP ranges' is used for Egress rules to specify where traffic can go."
                }
            },
            {
                title: "Q21: Data Retention Policy for Regulatory Compliance",
                description: "Your company has a regulatory requirement to retain specific log data for seven years. This data is rarely accessed after the first 30 days. You need a cost-effective storage solution that meets this retention policy. Which Cloud Storage class should you use?",
                options: ["Standard", "Nearline", "Coldline", "Archive"],
                correctAnswer: "Archive",
                feedback: {
                    "Standard": "Incorrect. Too expensive for data that is rarely accessed.",
                    "Nearline": "Incorrect. Optimized for data accessed about once a month.",
                    "Coldline": "Incorrect. Optimized for data accessed about once a quarter.",
                    "Archive": "Correct! Archive storage is the most cost-effective option for long-term (years) retention of data that is accessed less than once a year."
                }
            },
            {
                title: "Q22: Serverless Application Development with Event-Driven Functions",
                description: "Your company wants to develop a new application that processes events from various sources (e.g., file uploads, database changes, messages on a queue). They want to use a fully managed, serverless platform that automatically scales and requires minimal operational overhead for individual pieces of logic. Which service should you choose?",
                options: ["Google App Engine", "Google Kubernetes Engine", "Google Cloud Functions", "Google Compute Engine"],
                correctAnswer: "Google Cloud Functions",
                feedback: {
                    "Google App Engine": "Incorrect. This is a Platform-as-a-Service (PaaS) for running full applications, not for small, event-driven pieces of logic.",
                    "Google Kubernetes Engine": "Incorrect. This is a container orchestration platform and involves more operational overhead than a serverless functions platform.",
                    "Google Cloud Functions": "Correct! This is a Function-as-a-Service (FaaS) platform, perfect for running small, event-driven code snippets in a fully managed, serverless environment.",
                    "Google Compute Engine": "Incorrect. This provides raw VMs (IaaS) and requires the most operational management."
                }
            },
            {
                title: "Q23: Managing Secrets and Certificates in GKE",
                description: "Your application running on Google Kubernetes Engine (GKE) requires access to sensitive information like API keys and SSL/TLS certificates. You need a secure and manageable way to store and inject these secrets into your application pods. Which method should you use?",
                options: [
                    "Store secrets directly in Docker images.",
                    "Use Kubernetes Secrets.",
                    "Mount secrets from a Cloud Storage bucket.",
                    "Hardcode secrets in application code."
                ],
                correctAnswer: "Use Kubernetes Secrets.",
                feedback: {
                    "Store secrets directly in Docker images.": "Incorrect. This is highly insecure as anyone with access to the image can extract the secrets.",
                    "Use Kubernetes Secrets.": "Correct! Kubernetes Secrets are the native, secure, and standard way to store and manage sensitive information and make it available to pods.",
                    "Mount secrets from a Cloud Storage bucket.": "Incorrect. This requires custom logic and managing IAM permissions, making it less integrated and more complex than using native Secrets.",
                    "Hardcode secrets in application code.": "Incorrect. This is extremely insecure and makes rotating secrets very difficult."
                }
            },
            {
                title: "Q24: Migrating On-Premise Relational Database (Minimal Change)",
                description: "Your company wants to migrate an existing on-premises relational database (PostgreSQL) to Google Cloud with minimal changes to the application code. They need a fully managed service. Which service should you choose?",
                options: ["Google Cloud Spanner", "Google Cloud Bigtable", "Google Cloud SQL", "Google Cloud Datastore"],
                correctAnswer: "Google Cloud SQL",
                feedback: {
                    "Google Cloud Spanner": "Incorrect. Spanner is a globally distributed relational database, but migrating to it from a traditional RDBMS like PostgreSQL often requires schema and application code changes.",
                    "Google Cloud Bigtable": "Incorrect. This is a NoSQL database.",
                    "Google Cloud SQL": "Correct! Cloud SQL provides fully managed instances of common relational databases like PostgreSQL, MySQL, and SQL Server, making it ideal for a 'lift-and-shift' migration with minimal changes.",
                    "Google Cloud Datastore": "Incorrect. This is a NoSQL database."
                }
            },
            {
                title: "Q25: Network Performance for Direct Traffic to GCE VMs",
                description: "Your company has an application running on Compute Engine VMs that experiences high network latency for direct inbound traffic from the internet. They need to optimize network performance for these connections. What should they do?",
                options: [
                    "Deploy a Global Load Balancer in front of the VMs.",
                    "Use a Cloud VPN connection.",
                    "Increase the network bandwidth of the VMs.",
                    "Enable VPC Service Controls."
                ],
                correctAnswer: "Deploy a Global Load Balancer in front of the VMs.",
                feedback: {
                    "Deploy a Global Load Balancer in front of the VMs.": "Correct! A global external HTTP(S) load balancer uses Google's premium network tier and global edge locations to route users to the closest healthy backend, significantly reducing latency.",
                    "Use a Cloud VPN connection.": "Incorrect. VPN is for securing traffic between on-premises and GCP, not for optimizing public internet traffic.",
                    "Increase the network bandwidth of the VMs.": "Incorrect. This might help if the VM itself is the bottleneck, but it won't improve the latency of the network path from the user to the VM.",
                    "Enable VPC Service Controls.": "Incorrect. This is a security feature to prevent data exfiltration, not a performance optimization tool."
                }
            },
            {
                title: "Q26: Storing and Querying High-Volume Log Data",
                description: "Your application generates a very high volume of log data that needs to be stored and efficiently queried for debugging and auditing purposes. The data will grow over time, and you need a scalable solution. Which Google Cloud services should you use?",
                options: [
                    "Cloud Storage for logs, and Cloud SQL for queries.",
                    "Cloud Logging for ingestion and storage, and BigQuery for analytical queries.",
                    "Cloud Datastore for logs, and Cloud Functions for queries.",
                    "Cloud Bigtable for logs, and Dataflow for queries."
                ],
                correctAnswer: "Cloud Logging for ingestion and storage, and BigQuery for analytical queries.",
                feedback: {
                    "Cloud Storage for logs, and Cloud SQL for queries.": "Incorrect. Cloud SQL is not designed for scalable analysis of high-volume log data.",
                    "Cloud Logging for ingestion and storage, and BigQuery for analytical queries.": "Correct! This is the standard GCP pattern. Cloud Logging handles the ingestion and storage, and you can create a sink to export logs to BigQuery for powerful, scalable SQL-based analysis.",
                    "Cloud Datastore for logs, and Cloud Functions for queries.": "Incorrect. This solution is not scalable for high-volume log analysis.",
                    "Cloud Bigtable for logs, and Dataflow for queries.": "Incorrect. While Bigtable can store logs, BigQuery is the superior tool for ad-hoc analytical querying. Dataflow is for data processing, not querying."
                }
            },
            {
                title: "Q27: Managing User Access to Multiple Projects",
                description: "Your company has multiple Google Cloud projects, each for a different team (e.g., Development, Staging, Production). You need to manage user access centrally and consistently across these projects. Which IAM feature should you use?",
                options: ["Service Accounts", "Custom Roles", "Organizations and Folders", "Project IAM policies"],
                correctAnswer: "Organizations and Folders",
                feedback: {
                    "Service Accounts": "Incorrect. Service accounts are for applications, not for managing human user access across projects.",
                    "Custom Roles": "Incorrect. Custom roles define sets of permissions, but they don't provide a way to apply those permissions hierarchically across many projects.",
                    "Organizations and Folders": "Correct! The resource hierarchy (Organization > Folders > Projects) allows you to set IAM policies at higher levels (like a folder for the 'Development' team) that are inherited by all projects within, enabling centralized and consistent access management.",
                    "Project IAM policies": "Incorrect. This manages access on a per-project basis, which is not centralized or efficient for many projects."
                }
            },
            {
                title: "Q28: Designing for High Availability for a Stateful Application",
                description: "You are designing a critical, stateful application that needs to be highly available across multiple zones within a region. If an instance fails, it should quickly fail over to another healthy instance, retaining its state. Which design pattern should you use for state?",
                options: [
                    "Store state in local disk and use persistent disk snapshots for backup.",
                    "Store state in an external, highly available database service.",
                    "Store state in a distributed cache like Redis and replicate it.",
                    "Store state in a Google Cloud Storage bucket."
                ],
                correctAnswer: "Store state in an external, highly available database service.",
                feedback: {
                    "Store state in local disk and use persistent disk snapshots for backup.": "Incorrect. This leads to a high recovery time (RTO) as you would need to restore a snapshot to a new disk, which is not suitable for quick failover.",
                    "Store state in an external, highly available database service.": "Correct! Externalizing state to a managed, multi-zone service (like multi-region Cloud SQL or Cloud Spanner) allows any application instance to access the state, making the application itself stateless and enabling quick failover.",
                    "Store state in a distributed cache like Redis and replicate it.": "Incorrect. While a cache (like Memorystore) is often part of the solution for performance, a database provides stronger durability guarantees for critical state.",
                    "Store state in a Google Cloud Storage bucket.": "Incorrect. Cloud Storage is object storage and is not suitable for the low-latency read/write operations required for live application state."
                }
            },
            {
                title: "Q29: Network Connectivity for Hybrid Cloud (High Bandwidth)",
                description: "Your company needs to establish high-bandwidth, low-latency, and secure connectivity between its on-premises data center and Google Cloud for mission-critical applications. Which networking solution should you choose?",
                options: ["Cloud VPN", "Direct Peering", "Partner Interconnect", "Dedicated Interconnect"],
                correctAnswer: "Dedicated Interconnect",
                feedback: {
                    "Cloud VPN": "Incorrect. Cloud VPN operates over the public internet and cannot guarantee the high bandwidth or low latency required for mission-critical applications.",
                    "Direct Peering": "Incorrect. Direct Peering is for reaching Google's public services, not for private access to your VPC.",
                    "Partner Interconnect": "Incorrect. This provides a private connection through a partner, which is a good option, but Dedicated Interconnect offers the highest bandwidth and lowest latency.",
                    "Dedicated Interconnect": "Correct! This provides a direct, private, physical connection between your data center and Google's network, offering the highest bandwidth (10 or 100 Gbps), lowest latency, and greatest reliability."
                }
            },
            {
                title: "Q30: Migrating a Monolithic Application to Containers (Minimal Refactoring)",
                description: "Your company has a monolithic application running on VMs. They want to migrate it to a containerized environment on Google Cloud with minimal refactoring to gain scalability and portability benefits. Which service should you use?",
                options: ["Google App Engine", "Google Kubernetes Engine (GKE)", "Google Cloud Functions", "Google Compute Engine"],
                correctAnswer: "Google Kubernetes Engine (GKE)",
                feedback: {
                    "Google App Engine": "Incorrect. Migrating a complex monolith to App Engine often requires significant refactoring to fit its specific structure.",
                    "Google Kubernetes Engine (GKE)": "Correct! You can containerize a monolithic application and deploy it to GKE with minimal changes. This 'lift-and-shift' approach provides immediate benefits like orchestration and portability, serving as a first step before potential refactoring into microservices.",
                    "Google Cloud Functions": "Incorrect. This is for functions, not for running a large monolithic application.",
                    "Google Compute Engine": "Incorrect. This is just moving from on-prem VMs to cloud VMs, which doesn't provide the desired containerization benefits."
                }
            },
            {
                title: "Q31: Securing Internal HTTP Traffic between Microservices",
                description: "Your microservices application runs on Google Kubernetes Engine (GKE). You need to secure the internal HTTP communication between your microservices, ensuring that only authorized services can communicate with each other. Which approach should you use?",
                options: [
                    "Use Network Policies to restrict traffic.",
                    "Implement mTLS (mutual TLS) using a service mesh like Istio.",
                    "Configure firewall rules within the GKE cluster.",
                    "Use internal load balancing to encrypt traffic."
                ],
                correctAnswer: "Implement mTLS (mutual TLS) using a service mesh like Istio.",
                feedback: {
                    "Use Network Policies to restrict traffic.": "Incorrect. Network Policies operate at Layer 3/4 (IP/port) to restrict which pods can communicate, but they do not encrypt the traffic or verify service identity at Layer 7.",
                    "Implement mTLS (mutual TLS) using a service mesh like Istio.": "Correct! A service mesh provides mTLS, which encrypts all traffic between services and provides strong, identity-based authentication, ensuring that communication is both private and authorized.",
                    "Configure firewall rules within the GKE cluster.": "Incorrect. GCP firewall rules operate at the VM (node) level, not at the fine-grained service-to-service level within a cluster.",
                    "Use internal load balancing to encrypt traffic.": "Incorrect. An internal load balancer distributes traffic but does not inherently encrypt the communication between all microservices."
                }
            },
            {
                title: "Q32: Real-time Data Streaming and Processing",
                description: "Your company has a new product that generates continuous streams of data from user interactions. You need to ingest this data in real time, process it, and load it into a data warehouse for immediate analysis. Which combination of services should you use?",
                options: [
                    "Cloud Storage and Dataflow.",
                    "Pub/Sub and Dataflow.",
                    "Cloud SQL and Dataproc.",
                    "Cloud Bigtable and BigQuery."
                ],
                correctAnswer: "Pub/Sub and Dataflow.",
                feedback: {
                    "Cloud Storage and Dataflow.": "Incorrect. Cloud Storage is for batch data, not for ingesting real-time streams.",
                    "Pub/Sub and Dataflow.": "Correct! This is the canonical GCP pattern for stream processing. Pub/Sub provides a scalable, real-time messaging service for ingestion, and Dataflow provides a powerful, managed platform for processing those streams.",
                    "Cloud SQL and Dataproc.": "Incorrect. These services are primarily for transactional databases and batch processing, respectively, not real-time streaming.",
                    "Cloud Bigtable and BigQuery.": "Incorrect. While these can be destinations for the data, they are not the ingestion and processing components."
                }
            },
            {
                title: "Q33: Monitoring Application Performance and Logs",
                description: "Your development team needs a comprehensive solution to monitor application performance, track errors, and analyze logs in real time across your Google Cloud environment. Which service should they primarily use?",
                options: ["Cloud Source Repositories", "Cloud Build", "Cloud Monitoring", "Cloud Trace"],
                correctAnswer: "Cloud Monitoring",
                feedback: {
                    "Cloud Source Repositories": "Incorrect. This is a source code repository (Git).",
                    "Cloud Build": "Incorrect. This is a CI/CD service for building and testing code.",
                    "Cloud Monitoring": "Correct! Cloud Monitoring (part of the Cloud Operations suite) is the centralized service for collecting and visualizing metrics, logs, and traces to provide comprehensive monitoring.",
                    "Cloud Trace": "Incorrect. Cloud Trace is a component of the monitoring suite specifically for analyzing latency in distributed systems, but it is not the overall solution."
                }
            },
            {
                title: "Q34: Cost-Effective Storage for Infrequently Accessed Archival Data",
                description: "Your company has a large volume of historical data that needs to be stored for compliance reasons. This data is rarely accessed (less than once a year) but must be retained for decades. You need the most cost-effective storage option. Which Cloud Storage class should you use?",
                options: ["Standard", "Nearline", "Coldline", "Archive"],
                correctAnswer: "Archive",
                feedback: {
                    "Standard": "Incorrect. This is the most expensive class, for frequently accessed data.",
                    "Nearline": "Incorrect. For data accessed about once a month.",
                    "Coldline": "Incorrect. For data accessed about once a quarter.",
                    "Archive": "Correct! Archive storage has the lowest storage cost, making it ideal for long-term retention of data that is accessed very rarely."
                }
            },
            {
                title: "Q35: Automating VM Deployment and Scaling",
                description: "You need to deploy a fleet of Compute Engine VMs that run identical web servers. The number of VMs needs to automatically scale up or down based on traffic load. You also want to automate the deployment of these VMs. Which Compute Engine feature should you use?",
                options: [
                    "Custom images and startup scripts.",
                    "Instance templates and managed instance groups.",
                    "Sole-tenant nodes and autoscaling.",
                    "Snapshots and instance templates."
                ],
                correctAnswer: "Instance templates and managed instance groups.",
                feedback: {
                    "Custom images and startup scripts.": "Incorrect. These are components but not the complete solution for automated deployment and scaling.",
                    "Instance templates and managed instance groups.": "Correct! An instance template defines the configuration of the VMs. A managed instance group (MIG) uses that template to create, manage, and autoscale a group of identical VMs.",
                    "Sole-tenant nodes and autoscaling.": "Incorrect. Sole-tenant nodes are for dedicated hardware, not a general-purpose scaling solution.",
                    "Snapshots and instance templates.": "Incorrect. Snapshots are for disk backups, not for managing a fleet of active VMs."
                }
            },
            {
                title: "Q36: Centralized Log Collection and Aggregation",
                description: "Your company operates applications across multiple Google Cloud projects. You need to centralize all application and infrastructure logs from these projects into a single location for easier analysis and compliance. Which service should you use?",
                options: ["Cloud Storage", "Cloud Logging", "BigQuery", "Cloud SQL"],
                correctAnswer: "Cloud Logging",
                feedback: {
                    "Cloud Storage": "Incorrect. Cloud Storage can be a destination (sink) for logs, but it is not the service that performs the collection and aggregation.",
                    "Cloud Logging": "Correct! Cloud Logging is the centralized service for collecting, searching, and routing logs from all GCP services and projects. You can configure aggregated sinks to send logs from multiple projects to a single destination.",
                    "BigQuery": "Incorrect. BigQuery is a destination for logs for long-term storage and analysis, not the collection service itself.",
                    "Cloud SQL": "Incorrect. This is a relational database and is not suitable for high-volume log aggregation."
                }
            },
            {
                title: "Q37: Data Ingestion for Real-time Dashboards",
                description: "You are building a real-time analytics dashboard for your application. User clickstream data needs to be ingested continuously, transformed minimally, and then made available for immediate display on the dashboard. Which service should you use for ingestion?",
                options: ["Cloud Storage", "Cloud Pub/Sub", "Cloud Bigtable", "Cloud SQL"],
                correctAnswer: "Cloud Pub/Sub",
                feedback: {
                    "Cloud Storage": "Incorrect. Cloud Storage is for batch/file storage, not for real-time stream ingestion.",
                    "Cloud Pub/Sub": "Correct! Pub/Sub is a fully managed, real-time messaging service designed to ingest continuous streams of data from many sources, making it ideal for clickstream data.",
                    "Cloud Bigtable": "Incorrect. Bigtable can be a destination for the data, but Pub/Sub is the service used for the initial ingestion.",
                    "Cloud SQL": "Incorrect. A relational database is not suitable for high-throughput, real-time stream ingestion."
                }
            },
            {
                title: "Q38: Managing API Endpoints and Security",
                description: "Your company has multiple internal and external APIs that need to be centrally managed, secured, and monitored. You need a solution that can handle authentication, authorization, rate limiting, and analytics for all your APIs. Which service should you use?",
                options: ["Cloud Load Balancing", "API Gateway", "Cloud DNS", "Identity-Aware Proxy (IAP)"],
                correctAnswer: "API Gateway",
                feedback: {
                    "Cloud Load Balancing": "Incorrect. A load balancer distributes traffic but does not provide comprehensive API management features like authentication, rate limiting, and analytics.",
                    "API Gateway": "Correct! API Gateway is a fully managed service that allows you to create, secure, and monitor APIs. It provides a single point of entry and handles tasks like authentication, rate limiting, and monitoring.",
                    "Cloud DNS": "Incorrect. Cloud DNS is for managing domain names.",
                    "Identity-Aware Proxy (IAP)": "Incorrect. IAP is for securing access to web applications and VMs, not for general-purpose API management."
                }
            },
            {
                title: "Q39: Migrating a Data Warehouse for Scalability",
                description: "Your company currently runs an on-premises data warehouse that is struggling to scale with increasing data volumes and complex analytical queries. You need to migrate it to Google Cloud to achieve high scalability and performance for analytical workloads. Which service should you use?",
                options: ["Google Cloud SQL", "Google Cloud Spanner", "Google Cloud BigQuery", "Google Cloud Bigtable"],
                correctAnswer: "Google Cloud BigQuery",
                feedback: {
                    "Google Cloud SQL": "Incorrect. Cloud SQL is an OLTP database and is not designed for the scale and performance required for a data warehouse.",
                    "Google Cloud Spanner": "Incorrect. Spanner is for globally distributed transactional workloads (OLTP), not for data warehousing (OLAP).",
                    "Google Cloud BigQuery": "Correct! BigQuery is a serverless, highly scalable, and cost-effective enterprise data warehouse specifically designed for running analytical queries on massive datasets.",
                    "Google Cloud Bigtable": "Incorrect. Bigtable is a NoSQL database, not a relational data warehouse."
                }
            },
            {
                title: "Q40: Setting Up CI/CD for GKE Application",
                description: "You are deploying a new application to Google Kubernetes Engine (GKE). You need to set up a Continuous Integration/Continuous Delivery (CI/CD) pipeline that automatically builds your container images, tests them, and deploys them to GKE when code changes are committed. Which combination of services should you use?",
                options: [
                    "Cloud Source Repositories, Cloud Build, and Cloud Deploy.",
                    "Cloud Source Repositories, Cloud Functions, and Cloud Run.",
                    "Cloud Storage, Cloud Build, and Cloud Scheduler.",
                    "Cloud Code, Cloud Build, and Compute Engine."
                ],
                correctAnswer: "Cloud Source Repositories, Cloud Build, and Cloud Deploy.",
                feedback: {
                    "Cloud Source Repositories, Cloud Build, and Cloud Deploy.": "Correct! This combination provides a fully managed, native CI/CD pipeline on GCP: Cloud Source Repositories for code, Cloud Build for CI (build/test), and Cloud Deploy for CD to GKE.",
                    "Cloud Source Repositories, Cloud Functions, and Cloud Run.": "Incorrect. Functions and Run are deployment targets, not CI/CD pipeline tools for GKE.",
                    "Cloud Storage, Cloud Build, and Cloud Scheduler.": "Incorrect. Cloud Storage and Scheduler are not primary components of a CI/CD pipeline for GKE.",
                    "Cloud Code, Cloud Build, and Compute Engine.": "Incorrect. Cloud Code is an IDE plugin, and Compute Engine is for VMs, not a complete CI/CD solution for GKE."
                }
            },
            {
                title: "Q41: Optimizing Object Storage for Cost and Access (Variable Frequency)",
                description: "Your company stores large amounts of unstructured data (e.g., historical reports, media files) in Google Cloud Storage. The access patterns for this data vary: some files are accessed frequently for a short period, while others are accessed rarely after initial upload. You need to optimize storage costs while ensuring data is accessible when needed. What should you do?",
                options: [
                    "Use the Standard storage class for all data.",
                    "Use a Lifecycle Management policy to transition data between storage classes.",
                    "Use the Archive storage class for all data.",
                    "Use Nearline storage class for all data."
                ],
                correctAnswer: "Use a Lifecycle Management policy to transition data between storage classes.",
                feedback: {
                    "Use the Standard storage class for all data.": "Incorrect. This is not cost-effective for the data that is rarely accessed.",
                    "Use a Lifecycle Management policy to transition data between storage classes.": "Correct! Lifecycle Management allows you to automatically transition objects to cheaper storage classes (e.g., Standard -> Nearline -> Coldline) based on their age, which is the perfect way to optimize costs for data with variable access patterns.",
                    "Use the Archive storage class for all data.": "Incorrect. This would incur high retrieval costs and delays for the data that is accessed frequently.",
                    "Use Nearline storage class for all data.": "Incorrect. This is not optimal for data that is either very frequently or very rarely accessed."
                }
            },
            {
                title: "Q42: Data Processing for Big Data Batch Jobs",
                description: "Your data science team needs to process multi-terabyte datasets using Apache Spark batch jobs. They want a fully managed service that can quickly provision and scale Spark clusters without manual infrastructure management. Which service should you recommend?",
                options: ["Google Cloud Dataflow", "Google Cloud Dataproc", "Google Compute Engine", "Google Kubernetes Engine"],
                correctAnswer: "Google Cloud Dataproc",
                feedback: {
                    "Google Cloud Dataflow": "Incorrect. Dataflow is for Apache Beam pipelines, not for running native Apache Spark jobs.",
                    "Google Cloud Dataproc": "Correct! Dataproc is a fully managed service for running Apache Spark and Hadoop clusters, making it ideal for big data batch processing.",
                    "Google Compute Engine": "Incorrect. This would require manually setting up and managing the Spark clusters, which is not a managed service.",
                    "Google Kubernetes Engine": "Incorrect. While you can run Spark on Kubernetes, it requires more manual setup and management than Dataproc."
                }
            },
            {
                title: "Q43: Managing Network Access to Services within a VPC",
                description: "You have a multi-tier application deployed across different Compute Engine VMs within a single VPC Network. You need to restrict inbound network access to specific application services based on their internal IP addresses and ports, allowing only authorized communication between tiers. Which networking feature should you use?",
                options: ["Network Tags", "Firewall Rules", "VPC Service Controls", "Service Accounts"],
                correctAnswer: "Firewall Rules",
                feedback: {
                    "Network Tags": "Incorrect. Network tags are used to apply firewall rules to groups of VMs, but they are not the access control mechanism itself.",
                    "Firewall Rules": "Correct! VPC Firewall Rules are the primary mechanism for controlling traffic to and from VM instances based on IP addresses, ports, and protocols, allowing for fine-grained, tiered access control.",
                    "VPC Service Controls": "Incorrect. This is for creating a security perimeter around GCP services to prevent data exfiltration, not for controlling VM-to-VM traffic.",
                    "Service Accounts": "Incorrect. Service accounts can be used as a target for firewall rules, but the rule itself is the feature that controls access."
                }
            },
            {
                title: "Q44: Storing Session State for Highly Scalable Web App",
                description: "Your web application is experiencing high traffic and needs to scale horizontally across many instances. You need to store user session state securely and ensure it's accessible by any instance, even if an instance restarts or fails. Which solution should you choose?",
                options: [
                    "In-memory session on each web server instance.",
                    "Google Cloud Memorystore for Redis.",
                    "Client-side cookies with encrypted session data.",
                    "Persistent Disk attached to a single web server."
                ],
                correctAnswer: "Google Cloud Memorystore for Redis.",
                feedback: {
                    "In-memory session on each web server instance.": "Incorrect. This is not scalable, as session state is lost if an instance fails or if the user's next request goes to a different instance.",
                    "Google Cloud Memorystore for Redis.": "Correct! Memorystore provides a managed, in-memory data store (Redis) that is external to the application instances. This allows any instance to access the session state, making the application stateless and highly scalable.",
                    "Client-side cookies with encrypted session data.": "Incorrect. This has size limitations and potential security concerns, and is not suitable for complex session data.",
                    "Persistent Disk attached to a single web server.": "Incorrect. This creates a single point of failure and does not scale horizontally."
                }
            },
            {
                title: "Q45: Centralized User Directory for Hybrid Cloud",
                description: "Your company has an existing on-premises Active Directory for user management. They are migrating applications to Google Cloud and need to maintain a single source of truth for user identities. Users in the cloud should authenticate against the existing Active Directory. Which solution should you implement?",
                options: ["Set up Cloud Identity.", "Use Identity Platform.", "Implement Managed Microsoft AD.", "Configure Directory Sync."],
                correctAnswer: "Configure Directory Sync.",
                feedback: {
                    "Set up Cloud Identity.": "Incorrect. Cloud Identity is the destination for the synced identities, but it doesn't perform the synchronization itself.",
                    "Use Identity Platform.": "Incorrect. This is for managing customer-facing application identities, not for enterprise workforce identity.",
                    "Implement Managed Microsoft AD.": "Incorrect. This creates a new, managed AD in the cloud, but the requirement is to use the *existing* on-premises AD.",
                    "Configure Directory Sync.": "Correct! Google Cloud Directory Sync (GCDS) is the tool used to synchronize users, groups, and other data from your existing Active Directory to your Cloud Identity domain, establishing the on-prem AD as the source of truth."
                }
            },
            {
                title: "Q46: Event-Driven Architecture for Data Processing",
                description: "You need to design an architecture that processes incoming data files (e.g., CSVs, images) as soon as they are uploaded to a Cloud Storage bucket. The processing involves data validation and transformation. You want a serverless solution that is cost-effective and scales automatically. Which combination of services should you use?",
                options: [
                    "Cloud Storage with Cloud Functions.",
                    "Cloud Pub/Sub with Cloud Dataflow.",
                    "Cloud Storage with Compute Engine.",
                    "Cloud Pub/Sub with Cloud Run."
                ],
                correctAnswer: "Cloud Storage with Cloud Functions.",
                feedback: {
                    "Cloud Storage with Cloud Functions.": "Correct! This is a classic serverless, event-driven pattern. Cloud Functions can be configured with a Cloud Storage trigger to automatically execute code whenever a new file is uploaded to a bucket.",
                    "Cloud Pub/Sub with Cloud Dataflow.": "Incorrect. This pattern is better suited for streaming data, not for processing individual file uploads.",
                    "Cloud Storage with Compute Engine.": "Incorrect. This is not a serverless solution and would require you to manage VMs.",
                    "Cloud Pub/Sub with Cloud Run.": "Incorrect. While possible, using a Cloud Function with a direct Storage trigger is a more direct and simpler pattern for this use case."
                }
            },
            {
                title: "Q47: Database for Complex Analytics with Geospatial Data",
                description: "Your company needs to perform complex analytical queries on a large dataset that includes geospatial information. Data scientists need to run ad-hoc queries and combine geospatial data with other business data. Which database service should you choose?",
                options: ["Google Cloud SQL", "Google Cloud Spanner", "Google Cloud Bigtable", "Google BigQuery"],
                correctAnswer: "Google BigQuery",
                feedback: {
                    "Google Cloud SQL": "Incorrect. While it supports some geospatial data types, it is not optimized for the scale and complexity of analytical queries that BigQuery can handle.",
                    "Google Cloud Spanner": "Incorrect. Spanner is for transactional workloads, not for complex analytics.",
                    "Google Cloud Bigtable": "Incorrect. This is a NoSQL database and does not support SQL or complex geospatial queries.",
                    "Google BigQuery": "Correct! BigQuery is a data warehouse that excels at complex analytical queries and has robust, built-in support for geospatial data types and functions (GIS), making it the perfect tool for this use case."
                }
            },
            {
                title: "Q48: Disaster Recovery for Stateless Web Application",
                description: "You have a critical, stateless web application deployed on Google Compute Engine instances using Managed Instance Groups in a single region. You need a disaster recovery strategy that minimizes downtime in case of a regional outage. What should you do?",
                options: [
                    "Create regular snapshots of the persistent disks.",
                    "Set up a Multi-Region Load Balancer and deploy MIGs in another region.",
                    "Configure a Cloud VPN connection to an on-premises DR site.",
                    "Implement a manual failover process to a standby application in another zone."
                ],
                correctAnswer: "Set up a Multi-Region Load Balancer and deploy MIGs in another region.",
                feedback: {
                    "Create regular snapshots of the persistent disks.": "Incorrect. The application is stateless, so there is no critical state on the disks to snapshot. This is not a DR strategy for the application itself.",
                    "Set up a Multi-Region Load Balancer and deploy MIGs in another region.": "Correct! For a stateless application, DR is about routing traffic to a working copy of the application. A global load balancer can automatically detect a regional failure and direct all traffic to the healthy MIG in the other region.",
                    "Configure a Cloud VPN connection to an on-premises DR site.": "Incorrect. This is a hybrid cloud solution, not a cloud-native DR strategy.",
                    "Implement a manual failover process to a standby application in another zone.": "Incorrect. A zonal failure is not a regional outage. This solution is manual and does not protect against the failure of an entire region."
                }
            },
            {
                title: "Q49: Secure Access to Internal Applications (No VPN)",
                description: "Your development team needs to securely access several internal web applications running on Compute Engine VMs, without using a VPN. Access should be controlled based on user identity. Which service should you use?",
                options: ["Cloud VPN", "Cloud Interconnect", "Identity-Aware Proxy (IAP)", "Cloud Armor"],
                correctAnswer: "Identity-Aware Proxy (IAP)",
                feedback: {
                    "Cloud VPN": "Incorrect. The requirement specifically states 'without using a VPN'.",
                    "Cloud Interconnect": "Incorrect. This is for high-bandwidth private network connectivity, not for providing identity-based access to individual users.",
                    "Identity-Aware Proxy (IAP)": "Correct! IAP acts as a secure proxy that enforces access control policies based on user identity and context, allowing you to grant access to internal applications without requiring a VPN.",
                    "Cloud Armor": "Incorrect. Cloud Armor is a WAF and DDoS protection service; it protects applications from external threats but does not provide identity-based access for internal users."
                }
            },
            {
                title: "Q50: Centralized Metrics and Monitoring for Hybrid Environment",
                description: "Your company has applications running both on-premises and on Google Cloud. You need a single pane of glass to monitor performance metrics and logs from both environments. Which service should you use?",
                options: ["Cloud Logging", "Cloud Monitoring", "Cloud Trace", "Cloud Audit Logs"],
                correctAnswer: "Cloud Monitoring",
                feedback: {
                    "Cloud Logging": "Incorrect. Cloud Logging is primarily for logs, while Cloud Monitoring provides a unified view of both logs and metrics.",
                    "Cloud Monitoring": "Correct! Cloud Monitoring can ingest metrics and logs from both GCP and other environments (like on-premises) via its agent, providing a centralized 'single pane of glass' for a hybrid setup.",
                    "Cloud Trace": "Incorrect. This is specifically for distributed tracing, not for general-purpose monitoring.",
                    "Cloud Audit Logs": "Incorrect. This is for auditing administrative changes, not for application performance monitoring."
                }
            },
            {
                title: "Q51: Choosing a Database for Financial Ledger (Append-Only)",
                description: "Your company needs to store a financial ledger that requires append-only operations and extremely high write throughput. Data is typically accessed via range queries on the ledger entries. Which database should you use?",
                options: ["Google Cloud SQL", "Google Cloud Spanner", "Google Cloud Bigtable", "Google Cloud Firestore"],
                correctAnswer: "Google Cloud Bigtable",
                feedback: {
                    "Google Cloud SQL": "Incorrect. A relational database is not optimized for the extremely high, append-only write throughput of a ledger.",
                    "Google Cloud Spanner": "Incorrect. While it has strong consistency, it's not the most cost-effective or performant choice for a pure high-throughput, append-only workload compared to Bigtable.",
                    "Google Cloud Bigtable": "Correct! Bigtable is a NoSQL wide-column store that excels at high-throughput writes and fast range scans, making it a perfect fit for time-series or ledger-like data.",
                    "Google Cloud Firestore": "Incorrect. This is a document database for application data and does not scale to the write throughput required for a large-scale ledger."
                }
            },
            {
                title: "Q52: Data Ingestion for Batch Analytics (Cost-Effective)",
                description: "You need to ingest large batches of data files (e.g., daily CSV reports from partners) into Google Cloud Storage. This process should be cost-effective and reliable. Which method should you use?",
                options: [
                    "Use gsutil cp from a Compute Engine VM.",
                    "Use Storage Transfer Service.",
                    "Use Cloud Pub/Sub.",
                    "Use Cloud Dataflow."
                ],
                correctAnswer: "Use Storage Transfer Service.",
                feedback: {
                    "Use gsutil cp from a Compute Engine VM.": "Incorrect. This requires you to manage and pay for a VM to run the transfer, making it less cost-effective and less managed than other options.",
                    "Use Storage Transfer Service.": "Correct! This is a fully managed, serverless service designed for large-scale, scheduled, and reliable data transfers into Cloud Storage from online sources, making it very cost-effective.",
                    "Use Cloud Pub/Sub.": "Incorrect. This is for real-time streaming data, not for transferring large batches of files.",
                    "Use Cloud Dataflow.": "Incorrect. Dataflow is a data processing service. While it can write to Cloud Storage, it's not the primary tool for simple data transfer."
                }
            },
            {
                title: "Q53: Automating Infrastructure Deployment in Production",
                description: "Your company wants to automate the deployment of its production infrastructure (VPC, subnets, Compute Engine instances, load balancers) in Google Cloud. They need a declarative, repeatable, and version-controlled approach. Which tool should you use?",
                options: ["Cloud Console", "gcloud CLI", "Deployment Manager", "Cloud Shell"],
                correctAnswer: "Deployment Manager",
                feedback: {
                    "Cloud Console": "Incorrect. The console is for manual, imperative actions and is not repeatable or version-controlled.",
                    "gcloud CLI": "Incorrect. The gcloud CLI is also imperative. While it can be scripted, it's not a declarative Infrastructure as Code (IaC) tool.",
                    "Deployment Manager": "Correct! Deployment Manager (or Terraform) is Google Cloud's native IaC service, allowing you to define your infrastructure declaratively in templates that can be version-controlled and used for repeatable deployments.",
                    "Cloud Shell": "Incorrect. Cloud Shell is a temporary environment with the gcloud CLI pre-installed; it is not an IaC tool itself."
                }
            },
            {
                title: "Q54: Optimizing Web Application Latency Globally",
                description: "Your web application serves users globally. You need to minimize latency for users accessing the application from different geographic locations. Which load balancing solution should you use?",
                options: [
                    "Regional HTTP(S) Load Balancer",
                    "Internal HTTP(S) Load Balancer",
                    "External HTTP(S) Load Balancer (Global)",
                    "Network Load Balancer (External)"
                ],
                correctAnswer: "External HTTP(S) Load Balancer (Global)",
                feedback: {
                    "Regional HTTP(S) Load Balancer": "Incorrect. This only serves traffic from within a single region and does not optimize for a global user base.",
                    "Internal HTTP(S) Load Balancer": "Incorrect. This is for internal traffic within your VPC.",
                    "External HTTP(S) Load Balancer (Global)": "Correct! The global external HTTP(S) load balancer uses a single anycast IP address and Google's global network to route users to the closest healthy backend, providing the best performance and lowest latency for global users.",
                    "Network Load Balancer (External)": "Incorrect. This is a regional, Layer 4 load balancer and is not optimized for global HTTP/S traffic."
                }
            },
            {
                title: "Q55: Multi-Factor Authentication for GCP Console",
                description: "Your company wants to enhance the security of access to the Google Cloud Console for administrators. They need to implement a strong authentication method beyond just passwords. Which security feature should you enable?",
                options: ["VPC Service Controls", "Context-Aware Access", "Two-Step Verification", "Identity Platform"],
                correctAnswer: "Two-Step Verification",
                feedback: {
                    "VPC Service Controls": "Incorrect. This is for preventing data exfiltration, not for user authentication.",
                    "Context-Aware Access": "Incorrect. This allows you to create granular access policies, but the core feature for MFA is 2-Step Verification.",
                    "Two-Step Verification": "Correct! This is Google's term for Multi-Factor Authentication (MFA/2FA) and is the standard way to add an extra layer of security to user accounts.",
                    "Identity Platform": "Incorrect. This is for managing identities for customer-facing applications, not for securing access to the GCP console."
                }
            },
            {
                title: "Q56: Managing Multiple Cloud Resources as a Single Unit",
                description: "You are deploying a new application composed of several interdependent Google Cloud resources (e.g., Compute Engine instances, Cloud SQL databases, Cloud Storage buckets, Pub/Sub topics). You need to manage these resources as a single unit, ensuring consistent deployment and updates. Which concept should you use?",
                options: [
                    "Separate projects for each resource type.",
                    "Use a single project for all resources and manage manually.",
                    "Define them using a resource hierarchy (Organization, Folders, Projects).",
                    "Group them logically into a Cloud Deployment Manager template."
                ],
                correctAnswer: "Group them logically into a Cloud Deployment Manager template.",
                feedback: {
                    "Separate projects for each resource type.": "Incorrect. This would make managing the interdependent application very complex.",
                    "Use a single project for all resources and manage manually.": "Incorrect. Manual management is not consistent, repeatable, or version-controlled.",
                    "Define them using a resource hierarchy (Organization, Folders, Projects).": "Incorrect. The resource hierarchy is for organizing projects, not for managing a set of resources as a single application unit.",
                    "Group them logically into a Cloud Deployment Manager template.": "Correct! An Infrastructure as Code tool like Deployment Manager or Terraform allows you to define all the resources for an application in a template, which can then be deployed, updated, and deleted as a single, logical unit."
                }
            },
            {
                title: "Q57: Cost-Effective Storage for Infrequently Accessed Backups",
                description: "Your company performs daily backups of its on-premises databases and needs to store them in Google Cloud for disaster recovery. These backups are rarely accessed (only in case of disaster recovery), but must be retrieved quickly when needed. You need a cost-effective storage solution. Which Cloud Storage class should you choose?",
                options: ["Standard", "Nearline", "Coldline", "Archive"],
                correctAnswer: "Coldline",
                feedback: {
                    "Standard": "Incorrect. Too expensive for rarely accessed data.",
                    "Nearline": "Incorrect. Good for data accessed about once a month, but Coldline is more cost-effective for even less frequent access.",
                    "Coldline": "Correct! Coldline is designed for data accessed at most once a quarter. It offers low storage costs but still provides relatively fast retrieval (seconds), making it a good balance for DR backups.",
                    "Archive": "Incorrect. Archive has the lowest storage cost but high retrieval costs and latency (minutes to hours), which is not ideal if the data must be 'retrieved quickly'."
                }
            },
            {
                title: "Q58: Data Processing for Stream Analytics",
                description: "Your company has a system that generates real-time sensor data. You need to perform continuous, real-time analytics on this data to detect anomalies. Which Google Cloud service should you use for processing?",
                options: ["Google Cloud Dataproc", "Google Cloud Dataflow", "Google Cloud Composer", "Google BigQuery"],
                correctAnswer: "Google Cloud Dataflow",
                feedback: {
                    "Google Cloud Dataproc": "Incorrect. Dataproc is primarily for batch processing with Spark and Hadoop.",
                    "Google Cloud Dataflow": "Correct! Dataflow is a fully managed service for unified stream and batch data processing, making it the ideal choice for continuous, real-time analytics on streaming data.",
                    "Google Cloud Composer": "Incorrect. Composer is a workflow orchestration service (managed Airflow), not a stream processing engine.",
                    "Google BigQuery": "Incorrect. BigQuery can perform analytics on streaming data, but Dataflow is the service used for the complex, real-time processing and transformation of the stream itself."
                }
            },
            {
                title: "Q59: Network Design for Service-to-Service Communication (Internal)",
                description: "You are designing a microservices application on Google Kubernetes Engine (GKE). You need to enable secure and efficient communication between different microservices (pods) within the cluster. Which networking concept should you leverage?",
                options: ["External Load Balancer", "Service Mesh", "Shared VPC", "Kubernetes Services"],
                correctAnswer: "Kubernetes Services",
                feedback: {
                    "External Load Balancer": "Incorrect. This is for exposing services to traffic from outside the cluster.",
                    "Service Mesh": "Incorrect. A service mesh adds advanced capabilities (like mTLS, traffic control) on top of Kubernetes Services, but the fundamental concept for enabling communication is the Service object itself.",
                    "Shared VPC": "Incorrect. This is for sharing a VPC network across multiple projects, not for inter-service communication within a single cluster.",
                    "Kubernetes Services": "Correct! A Kubernetes Service provides a stable, abstract way to expose a set of pods as a network service. It gives them a stable IP address and DNS name, and load balances traffic, which is the fundamental mechanism for enabling communication between microservices in a cluster."
                }
            },
            {
                title: "Q60: Multi-Project Resource Organization",
                description: "Your company wants to organize its Google Cloud resources (projects, billing, IAM) into a hierarchical structure for better management and policy enforcement. They have multiple departments, each with its own set of projects. Which resource hierarchy component should you establish at the top level?",
                options: ["Folders", "Projects", "Organization", "Resource Groups"],
                correctAnswer: "Organization",
                feedback: {
                    "Folders": "Incorrect. Folders are used to group projects and exist within an Organization.",
                    "Projects": "Incorrect. Projects contain resources and are the base level of the hierarchy.",
                    "Organization": "Correct! The Organization node is the root of the Google Cloud resource hierarchy. It is associated with your company's domain and provides centralized control over all projects and billing.",
                    "Resource Groups": "Incorrect. This is not a standard component of the GCP resource hierarchy."
                }
            }
        ];

        // --- SCRIPT LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- State Management ---
            let currentQuestionIndex = 0;
            let userAnswers = new Array(quizData.length).fill(null);
            let score = 0;
            let shuffledOptionsMap = new Map();

            // --- DOM Elements ---
            const mainHeader = document.getElementById('main-header');
            const quizContainer = document.getElementById('quiz-container');
            const navigationContainer = document.getElementById('navigation-container');
            const resultsContainer = document.getElementById('results-container');
            const reviewContainer = document.getElementById('review-container');
            const reviewContent = document.getElementById('review-content');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const currentQSpan = document.getElementById('current-q-span');
            const totalQSpan = document.getElementById('total-q-span');
            const restartBtn = document.getElementById('restart-btn');
            const reviewBtn = document.getElementById('review-btn');
            const backToScoreBtn = document.getElementById('back-to-score-btn');
            const scoreText = document.getElementById('score-text');
            const scoreSummary = document.getElementById('score-summary');
            const progressBar = document.getElementById('progress-bar');

            // --- Icon SVGs ---
            const checkIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="text-green-600"><path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm13.36-1.814a.75.75 0 10-1.06-1.06L10.5 13.19l-1.72-1.72a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.06 0l4.5-4.5z" clip-rule="evenodd" /></svg>`;
            const crossIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="text-red-600"><path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm-1.72 6.97a.75.75 0 011.06 0L12 9.94l.72-.72a.75.75 0 111.06 1.06L13.06 12l.72.72a.75.75 0 11-1.06 1.06L12 13.06l-.72.72a.75.75 0 01-1.06-1.06l.72-.72-.72-.72a.75.75 0 010-1.06z" clip-rule="evenodd" /></svg>`;

            function shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            function loadQuestion() {
                const question = quizData[currentQuestionIndex];
                const isAnswered = userAnswers[currentQuestionIndex] !== null;
                const questionType = question.type || 'MULTIPLE_CHOICE';
                
                if (!shuffledOptionsMap.has(currentQuestionIndex)) {
                    shuffledOptionsMap.set(currentQuestionIndex, shuffleArray(question.options));
                }
                const currentShuffledOptions = shuffledOptionsMap.get(currentQuestionIndex);

                let optionsHtml = '';
                currentShuffledOptions.forEach((option, index) => {
                    let isSelected = false;
                    if (questionType === 'CHECKBOX') {
                        isSelected = userAnswers[currentQuestionIndex] && userAnswers[currentQuestionIndex].includes(option);
                    } else {
                        isSelected = userAnswers[currentQuestionIndex] === option;
                    }
                    
                    const optionLetter = String.fromCharCode(65 + index);

                    optionsHtml += `
                        <div class="quiz-option mt-4 p-4 rounded-lg flex items-center" data-option="${option}">
                            <input type="${questionType === 'CHECKBOX' ? 'checkbox' : 'radio'}" name="option" class="mr-4 pointer-events-none h-5 w-5 bg-transparent border-slate-300 text-blue-600 focus:ring-blue-500" ${isSelected ? 'checked' : ''} ${isAnswered ? 'disabled' : ''}>
                            <label class="flex-1 pointer-events-none"><span class="font-bold mr-2">${optionLetter}.</span>${option}</label><div class="status-icon ml-auto"></div>
                        </div>
                    `;
                });

                quizContainer.innerHTML = `
                    <div class="flex flex-col lg:flex-row lg:gap-8">
                        <div class="lg:w-5/12 lg:pr-8">
                            <h2 class="text-2xl lg:text-3xl font-bold">${question.title}</h2>
                            <p class="text-slate-600 mt-4 text-base lg:text-lg">${question.description}</p>
                        </div>
                        <div class="lg:w-7/12 mt-6 lg:mt-0">
                            <div id="options-container" class="${isAnswered ? 'answered' : ''}">
                                ${optionsHtml}
                            </div>
                            ${questionType === 'CHECKBOX' && !isAnswered ? '<button id="submit-btn" class="btn btn-primary mt-6 w-full py-3 px-4">Submit Answer</button>' : ''}
                        </div>
                    </div>
                    <div id="feedback-container" class="mt-6"></div>
                `;
                
                updateProgress();
                updateButtonStates();
                
                if (isAnswered) {
                    showFeedback();
                }

                addOptionListeners();
            }

            function addOptionListeners() {
                const question = quizData[currentQuestionIndex];
                const questionType = question.type || 'MULTIPLE_CHOICE';

                document.querySelectorAll('.quiz-option').forEach(optionEl => {
                    optionEl.addEventListener('click', (e) => {
                        if (userAnswers[currentQuestionIndex] !== null) return;

                        if (questionType === 'MULTIPLE_CHOICE') {
                            const selectedOption = optionEl.dataset.option;
                            userAnswers[currentQuestionIndex] = selectedOption;
                            showFeedback();
                        } else { 
                            const checkbox = e.currentTarget.querySelector('input');
                            checkbox.checked = !checkbox.checked;
                        }
                    });
                });

                if (questionType === 'CHECKBOX') {
                    const submitBtn = document.getElementById('submit-btn');
                    if (submitBtn) {
                        submitBtn.addEventListener('click', () => {
                            const selectedOptions = Array.from(document.querySelectorAll('.quiz-option input:checked')).map(input => input.parentElement.dataset.option);
                            userAnswers[currentQuestionIndex] = selectedOptions;
                            showFeedback();
                            submitBtn.style.display = 'none';
                        });
                    }
                }
            }

            function showFeedback() {
                const question = quizData[currentQuestionIndex];
                const userAnswer = userAnswers[currentQuestionIndex];
                const optionsContainer = document.getElementById('options-container');
                const feedbackContainer = document.getElementById('feedback-container');
                
                if (!optionsContainer) return;

                optionsContainer.classList.add('answered');
                optionsContainer.querySelectorAll('input').forEach(input => input.disabled = true);

                let isCorrect = false;
                if (question.type === 'CHECKBOX') {
                    const correctAnswers = new Set(question.correctAnswers);
                    const selectedAnswers = new Set(userAnswer || []);
                    isCorrect = correctAnswers.size === selectedAnswers.size && [...correctAnswers].every(val => selectedAnswers.has(val));
                } else {
                    isCorrect = userAnswer === question.correctAnswer;
                }

                document.querySelectorAll('.quiz-option').forEach(optionEl => {
                    const optionText = optionEl.dataset.option;
                    const statusIconEl = optionEl.querySelector('.status-icon');

                    if (question.type === 'CHECKBOX') {
                        const isCorrectChoice = question.correctAnswers.includes(optionText);
                        const isSelected = (userAnswer || []).includes(optionText);

                        if (isCorrectChoice) {
                            optionEl.classList.add('correct');
                            statusIconEl.innerHTML = checkIconSVG;
                        }
                        if (isSelected && !isCorrectChoice) {
                            optionEl.classList.add('incorrect');
                            statusIconEl.innerHTML = crossIconSVG;
                        }
                    } else {
                        if (optionText === question.correctAnswer) {
                            optionEl.classList.add('correct');
                            statusIconEl.innerHTML = checkIconSVG;
                        } else if (optionText === userAnswer) {
                            optionEl.classList.add('incorrect');
                            statusIconEl.innerHTML = crossIconSVG;
                        }
                    }
                });
                
                let feedbackHtml = `<p class="mt-2 text-sm font-semibold text-slate-700">Explanations:</p>`;
                
                const currentShuffledOptions = shuffledOptionsMap.get(currentQuestionIndex);
                currentShuffledOptions.forEach((option, index) => {
                    const explanation = question.feedback[option] || "No explanation available.";
                    let isCorrectOption = false;
                    const optionLetter = String.fromCharCode(65 + index);

                    if (question.type === 'CHECKBOX') {
                        isCorrectOption = question.correctAnswers.includes(option);
                    } else {
                        isCorrectOption = (option === question.correctAnswer);
                    }

                    const feedbackItemHtml = `<span class="font-bold mr-2">${optionLetter}.</span> ${explanation}`;

                    if (isCorrectOption) {
                        feedbackHtml += `<div class="mt-2 text-sm p-3 rounded bg-green-50 border-l-4 border-green-500 text-green-800">${feedbackItemHtml}</div>`;
                    } else {
                        feedbackHtml += `<div class="mt-2 text-sm p-3 rounded bg-red-50 border-l-4 border-red-500 text-red-800">${feedbackItemHtml}</div>`;
                    }
                });

                const feedbackColor = isCorrect ? 'bg-green-50/50 border-green-500' : 'bg-red-50/50 border-red-500';
                const feedbackTitle = isCorrect ? 'üéâ Correct! üéâ' : 'ü§î Not Quite...';
                
                feedbackContainer.innerHTML = `
                    <div class="feedback-card p-6 border-l-4 rounded-r-lg ${feedbackColor}">
                        <h3 class="font-bold text-lg text-slate-800">${feedbackTitle}</h3>
                        <div class="feedback-explanations">${feedbackHtml}</div>
                    </div>
                `;
                setTimeout(() => {
                    const card = document.querySelector('.feedback-card');
                    if(card) card.classList.add('show');
                }, 10);
            }

            function updateProgress() {
                const progressPercent = ((currentQuestionIndex + 1) / quizData.length) * 100;
                progressBar.style.width = `${progressPercent}%`;
                currentQSpan.textContent = currentQuestionIndex + 1;
                totalQSpan.textContent = quizData.length;
            }

            function updateButtonStates() {
                prevBtn.disabled = currentQuestionIndex === 0;
                if (currentQuestionIndex === quizData.length - 1) {
                    nextBtn.textContent = 'Finish Quiz';
                } else {
                    nextBtn.textContent = 'Next';
                }
            }

            function showResults() {
                score = 0;
                quizData.forEach((question, index) => {
                    const userAnswer = userAnswers[index];
                    if (question.type === 'CHECKBOX') {
                        const correctAnswers = new Set(question.correctAnswers);
                        const selectedAnswers = new Set(userAnswer || []);
                        if (correctAnswers.size === selectedAnswers.size && [...correctAnswers].every(val => selectedAnswers.has(val))) {
                            score++;
                        }
                    } else {
                        if (userAnswer === question.correctAnswer) {
                            score++;
                        }
                    }
                });

                const percentage = Math.round((score / quizData.length) * 100);
                scoreText.textContent = `${percentage}%`;
                scoreSummary.textContent = `You answered ${score} out of ${quizData.length} questions correctly.`;

                quizContainer.style.display = 'none';
                navigationContainer.style.display = 'none';
                mainHeader.style.display = 'none';
                resultsContainer.classList.remove('hidden');
                resultsContainer.style.display = 'block';

            }

            function showReview() {
                resultsContainer.style.display = 'none';
                reviewContainer.classList.remove('hidden');
                reviewContainer.style.display = 'block';
                
                let reviewHtml = '';
                quizData.forEach((question, index) => {
                    const userAnswer = userAnswers[index];
                    let isCorrect = false;
                    let userAnswerHtml = '';
                    let correctAnswerHtml = '';

                    if (question.type === 'CHECKBOX') {
                        const correctAnswers = new Set(question.correctAnswers);
                        const selectedAnswers = new Set(userAnswer || []);
                        isCorrect = correctAnswers.size === selectedAnswers.size && [...correctAnswers].every(val => selectedAnswers.has(val));
                        userAnswerHtml = (userAnswer || []).length > 0 ? (userAnswer || []).map(a => `<li>${a}</li>`).join('') : '<li>No answer</li>';
                        correctAnswerHtml = question.correctAnswers.map(a => `<li>${a}</li>`).join('');
                    } else {
                        isCorrect = userAnswer === question.correctAnswer;
                        userAnswerHtml = `<li>${userAnswer || 'No answer'}</li>`;
                        correctAnswerHtml = `<li>${question.correctAnswer}</li>`;
                    }
                    
                    const resultIcon = isCorrect 
                        ? `<span class="text-green-600 font-bold ml-2">‚úî Correct</span>` 
                        : `<span class="text-red-600 font-bold ml-2">‚úñ Incorrect</span>`;

                    reviewHtml += `
                        <div class="border-t border-slate-200 pt-4">
                            <p class="font-semibold text-lg text-slate-800">${question.title}${resultIcon}</p>
                            <p class="text-slate-600 mt-2">${question.description}</p>
                            <div class="text-sm mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <p class="font-bold mb-1 text-slate-500">Your Answer:</p>
                                    <ul class="list-disc list-inside ${isCorrect ? 'review-answer-correct' : 'review-answer-incorrect'}">${userAnswerHtml}</ul>
                                </div>
                                ${!isCorrect ? `<div>
                                    <p class="font-bold mb-1 text-slate-500">Correct Answer:</p>
                                    <ul class="list-disc list-inside review-answer-correct">${correctAnswerHtml}</ul>
                                </div>` : ''}
                            </div>
                        </div>
                    `;
                });
                reviewContent.innerHTML = reviewHtml;
            }

            function restartQuiz() {
                currentQuestionIndex = 0;
                userAnswers.fill(null);
                score = 0;
                shuffledOptionsMap.clear();
                
                resultsContainer.style.display = 'none';
                reviewContainer.style.display = 'none';
                quizContainer.style.display = 'block';
                navigationContainer.style.display = 'flex';
                mainHeader.style.display = 'block';
                
                loadQuestion();
            }

            // --- Event Listeners ---
            prevBtn.addEventListener('click', () => {
                if (currentQuestionIndex > 0) {
                    currentQuestionIndex--;
                    loadQuestion();
                }
            });

            nextBtn.addEventListener('click', () => {
                if (userAnswers[currentQuestionIndex] === null) {
                    if (!quizData[currentQuestionIndex].type || quizData[currentQuestionIndex].type === 'MULTIPLE_CHOICE') {
                        userAnswers[currentQuestionIndex] = ''; 
                    } else {
                        userAnswers[currentQuestionIndex] = [];
                    }
                }

                if (currentQuestionIndex < quizData.length - 1) {
                    currentQuestionIndex++;
                    loadQuestion();
                } else {
                    showResults();
                }
            });
            
            restartBtn.addEventListener('click', restartQuiz);
            reviewBtn.addEventListener('click', showReview);
            backToScoreBtn.addEventListener('click', () => {
                reviewContainer.style.display = 'none';
                resultsContainer.style.display = 'block';
            });

            // --- Initial Load ---
            if (typeof quizData === 'undefined') {
                quizContainer.innerHTML = `<p class="text-red-500 font-bold text-center">Error: Could not load questions. Make sure quizData.js is loaded correctly.</p>`;
                return;
            }
            loadQuestion();
        });
    </script>
</body>
</html>
